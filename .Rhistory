nc <- NCOL(x)
ij <- as.matrix(expand.grid(1:nc, 1:nc))
m <- as.matrix(x[ , ij[ , 1]] > x[ , ij[ ,2]])
matrix(colMeans(m), nc, nc, byrow = TRUE)
}
better <- compare.rates(LAM)
better[1:24, 85]
sir.old.new <- function(theta, prior, prior.new) {
log.g <- log(prior(theta))
log.g.new <- log(prior.new(theta))
wt <- exp(log.g.new - log.g - max(log.g.new - log.g))
probs <- wt/sum(wt)
n <- length(probs)
indices <- sample(1:n, size = n, prob = probs, replace = TRUE)
theta[indices]
}
prior <- function(theta)
0.53*exp(theta)/(exp(theta) + 0.53)^2
prior.new <- function(theta)
5*exp(theta)/(exp(theta) + 5)^2
log.alpha <- fitgibbs$par[ , 1]
log.alpha.new <- sir.old.new(log.alpha, prior, prior.new)
draw.graph <- function() {
LOG.ALPHA <- data.frame("prior", log.alpha)
names(LOG.ALPHA) <- c("Prior", "log.alpha")
LOG.ALPHA.NEW <- data.frame("new.prior", log.alpha.new)
names(LOG.ALPHA.NEW) <- c("Prior", "log.alpha")
D <- densityplot(~log.alpha, group = Prior, data = rbind(LOG.ALPHA, LOG.ALPHA.NEW), plot.points = FALSE,
main = "Original Prior and Posterior (solid), New Prior and Posterior (dashed)",
lwd = 4, adjust = 2, lty = c(1, 2), xlab = "log alpha", xlim = c(-3, 5), col = "black")
update(D, panel = function(...) {
panel.curve(prior(x)    , lty = 1, lwd = 2, col = "black")
panel.curve(prior.new(x), lty = 2, lwd = 2, col = "black")
panel.densityplot(...)
})
}
draw.graph()
prob.int.rate <- function(i,log.alpha) {
lami <- rgamma(1000, y[i] + exp(log.alpha), e[i] + exp(log.alpha)/mu)
quantile(lami, c(0.05, 0.95))
}
ind <- c(1, 25, 57, 89)
ci <- sapply(ind, prob.int.rate, log.alpha)
matplot(matrix(log(e[ind]), 2, length(ind), byrow = TRUE), ci,
type = "l", lwd = 4, lty = 1,
xlim = c(6, 9.7), ylim = c(0, 0.002), ylab = "True Rate", xlab = "log(e)")
prob.int.rate <- function(i, log.alpha) {
lami <- with(hearttransplants, rgamma(1000, y[i] + exp(log.alpha), e[i] + exp(log.alpha)/mu))
quantile(lami, c(0.05, 0.95))
}
ind <- c(1, 25, 57, 89)
ci <- sapply(ind, prob.int.rate, log.alpha)
matplot(matrix(log(hearttransplants$e[ind]), 2, length(ind), byrow = TRUE)       , ci,
type = "l", lwd = 4, lty = 1,
xlim = c(6, 9.7), ylim = c(0, 0.002), ylab = "True Rate", xlab = "log(e)")
ci <- sapply(ind, prob.int.rate, log.alpha.new)
matplot(matrix(log(hearttransplants$e[ind]), 2, length(ind), byrow = TRUE) + 0.05, ci,
type = "l", lwd = 4, lty = 3, add = TRUE)
lam94 <- with(hearttransplants, rgamma(1000, y[94] + alpha, e[94] + alpha/mu))
ys94 <- rpois(1000, hearttransplants$e[94]*lam94)
hist(ys94, breaks = seq(-0.5, max(ys94) + 0.5))
lines(y[94]*c(1, 1), c(0, 100), lwd = 3)
lines(hearttransplants$y[94]*c(1, 1), c(0, 100), lwd = 3)
prob.out <- function(i) {
lami <- with(hearttransplants, rgamma(1000, y[i] + alpha, e[i] + alpha/mu))
ysi <- rpois(1000, hearttransplants$e[i]*lami)
pleft  <- sum(ysi <= hearttransplants$y[i])/1000
pright <- sum(ysi >= hearttransplants$y[i])/1000
min(pleft, pright)
}
pout.exchange <- sapply(hospital, prob.out)
plot(pout, pout.exchange, xlab = "P(extreme), equal means", ylab = "P(extreme), exchangeable")
abline(0, 1)
par(pty = "s")
plot(pout, pout.exchange, xlab = "P(extreme), equal means", ylab = "P(extreme), exchangeable")
abline(0, 1)
install.packages("sqldf")
library(sqldf)
sqldf("create table test (id);")
sqldf("create table test (id);", dbname = "test.db")
objects()
rm(bom)
rm(dsw)
rm(ndsw)
rm(today)
rm(vars)
objects()
library(sqldf)
library(sqldf)
DF <- sqldf("create table test (id);", dbname = "test.db")
objects()
DF
class(DF)
mode(DF)
str(DF)
sqldf("attach 'test' as new")
sqldf("create table test (id)", dbname = "test")
sqldf("select * from test", dbname = "test")
rm(DF)
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER
);")
sqldf("attach 'ex1' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER
);" dbname = "ex1")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER
);", dbname = "ex1")
ls()
sqldf("select * from person", dbname = "ex1")
sqldf("attach 'ex1' as new")
sqldf("create table person (
id integer primary key,
first_name text,
last_name text,
age integer
);", dbname = "ex1")
sqldf("select * from person", dbname = "ex1")
sqldf("attach 'ex1' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER,
gender TEXT,
weight INTEGER,
inches INTEGER
);", dbname = "ex1")
sqldf("select * from person", dbname = "ex1")
sqldf("attach 'ex1' as new")
sqldf("create table person (
id integer primary key,
first_name text,
last_name text,
age integer
);", dbname = "ex1")
sqldf("select * from person", dbname = "ex1")
sqldf("attach 'ex1a' as new")
sqldf("create table person (
id integer primary key,
first_name text,
last_name text,
age integer
);", dbname = "ex1a")
sqldf("select * from person", dbname = "ex1a")
sqldf("attach 'ex1b' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
first_name TEXT,
last_name TEXT,
age INTEGER,
gender TEXT,
weight INTEGER,
inches INTEGER
);", dbname = "ex1b")
sqldf("select * from person", dbname = "ex1b")
sqldf("attach 'ex2' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
firstName TEXT,
lastName TEXT,
age INTEGER
);", dbname = "ex2")
sqldf("CREATE TABLE personPet (
personId INTEGER,
petId INTEGER
);", dbname = "ex2")
sqldf("CREATE TABLE pet (
id INTEGER PRIMARY KEY,
name TEXT,
breed TEXT,
age INTEGER,
dead INTEGER
);", dbname = "ex2")
sqldf("select * from person", dbname = "ex2")
sqldf("select * from personPet", dbname = "ex2")
sqldf("select * from pet", dbname = "ex2")
library(sqldf)
sqldf("attach 'ex2' as new")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
firstName TEXT,
lastName TEXT,
age INTEGER
);", dbname = "ex2")
sqldf("CREATE TABLE person (
id INTEGER PRIMARY KEY,
firstName TEXT,
lastName TEXT,
age INTEGER
);", dbname = "ex2")
submission.to_csv('benchmark.csv', index = False)
library(rattle)
rattle()
- To avoid recomputing a value that is used repeatedly. For example, if you are performing computations involving e, you might want to compute it once and save the result.
To make the connection between the code and the underlying mathematics more apparent. If you are computing the area of a circle, you might want to use a variable named r:
attach(birthwt)
library(MASS)
attach(birthwt)
race <- factor(race, labels = c("white", "black", "other"))
table(ptl)
ptd <- factor(ptl > 0)
table(ftv)
ftv <- factor(ftv)
levels(ftv)[-(1:2)] <- "2+"
table(ftv) # as a check
bwt <- data.frame(low = factor(low), age, lwt, race,
smoke = (smoke > 0), ptd, ht = (ht > 0), ui = (ui > 0), ftv)
detach()
suppressPackageStartupMessages(library(SOAR)) # picky!
suppressPackageStartupMessages(library(MASS))
BirthWt <- within(birthwt, {
race <- factor(race, labels = c("white", "black", "other"))
ptl <- ptl > 0
ftv <- factor(ftv)
levels(ftv)[-(1:2)] <- "2+"
low <- factor(low, labels = c("normal", "low"))
smoke <- (smoke > 0)
ht <- (ht > 0)
ui <- (ui > 0)
bwt <- NULL ## remove actual birth weight
})
Store(BirthWt)
head(BirthWt, 2)
options(show.signif.stars = FALSE)
stepAIC <- function(..., trace = FALSE) # change default
MASS::stepAIC(..., trace = trace)
dropterm <- function(..., sorted = TRUE) # change default
MASS::dropterm(..., sorted = sorted)
BW0 <- glm(low ~ ., binomial, BirthWt)
dropterm(BW0, test = "Chisq")
# Screen for possible interactions:
sBW0 <- stepAIC(BW0, scope = list(lower = ~1, upper = ~.^2))
dropterm(sBW0, test = "Chisq")
# Session information
sessionInfo()
install.packages("compiler")
require(compiler)
vectorized <- function() {
a <- c(1, 1)
b <- c(2, 2)
x <- c(NaN, NaN)
for (i in 1:1000000) {
x <- a + b
}
return()
}
time <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
vectorized()
end <- Sys.time()
timings[itr] <- end - start
}
return(timings)
}
mean(time(10))
devectorized <- function() {
a <- c(1, 1)
b <- c(2, 2)
x <- c(NaN, NaN)
for (i in 1:1000000) {
for (index in 1:2) {
x[index] <- a[index] + b[index]
}
}
return()
}
time <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
devectorized()
end <- Sys.time()
timings[itr] <- end - start
}
return(timings)
}
mean(time(10))
require(compiler)
devectorized_cmp <- cmpfun(devectorized)
time_cmp <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
devectorized_cmp()
end <- Sys.time()
timings[itr] <- end – start
}
return(timings)
}
time_cmp <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
devectorized_cmp()
end <- Sys.time()
timings[itr] <- end - start
}
return(timings)
}
mean(time_cmp(10))
vectorized_cmp <- cmpfun(vectorized)
time_cmp <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
vectorized_cmp()
end <- Sys.time()
timings[itr] <- end – start
}
return(timings)
}
time_cmp <- function (N) {
timings <- rep(NA, N)
for (itr in 1:N) {
start <- Sys.time()
vectorized_cmp()
end <- Sys.time()
timings[itr] <- end - start
}
return(timings)
}
mean(time_cmp(10))
sessionInfo()
df1 <- data.frame(ID = c(1, 2), Obs = c(1.0, 2.0))
df2 <- data.frame(ID = c(1, 2), Obs = c(2.0, 3.0))
df3 <- (df1 + df2) / 2
df3
df1 <- data.frame(ID = c(1, 2), Obs = c(1.0, 2.0))
df2 <- data.frame(ID = c(2, 1), Obs = c(3.0, 2.0))
df3 <- (df1 + df2) / 2
df3
df1 <- data.frame(ID = c(1, 2), Obs = c(1.0, 2.0))
df2 <- data.frame(ID = c(2, 1), Obs = c(3.0, 2.0))
df3 <- merge(df1, df2, by = "ID")
df3 <- transform(df3, AvgObs = (Obs.x + Obs.y) / 2)
df3
df1 <- data.frame(ID = c(1, 2), Obs = c(1.0, 2.0))
df2 <- data.frame(ID = c(1, 2, 3), Obs = c(5.0, 6.0, 7.0))
df3 <- merge(df1, df2, by = "ID")
df3 <- transform(df3, AvgObs = (Obs.x + Obs.y) / 2)
df3
if(require(tree)) {
janka.tm <- tree(Hardness ~ Density, janka)
plot(janka.tm)
text(janka.tm)
}
setwd("~/GitHub/Venables")
janka <- read.csv("janka.csv", header = TRUE)
str(janka)
if(require(tree)) {
janka.tm <- tree(Hardness ~ Density, janka)
plot(janka.tm)
text(janka.tm)
}
if(require(tree)) {
partition.tree(janka.tm)
points(Hardness ~ Density, janka, col = "brown")
}
require(rpart)
janka.rm <- rpart(Hardness ~ Density, janka,
control = rpart.control(cp = 0.001, minsize = 3))
plot(janka.rm)
text(janka.rm, xpd = NA)
plotcp(janka.rm)
janka.rmp <- prune(janka.rm, cp = oneSERule(janka.rm))
oneSERule <- function (tree, f, ...)
UseMethod("oneSERule")
oneSERule.rpart <- function (tree, f = 1, ...) {
cp <- data.frame(tree$cptable) #$
imin <- with(cp, which(xerror == min(xerror))[1])
with(cp, CP[which(xerror <= xerror[imin] + f * xstd[imin])[1]])
}
Store(oneSERule, oneSERule.rpart) # to make available later
library(SOAR)
Store(oneSERule, oneSERule.rpart) # to make available later
janka.rmp <- prune(janka.rm, cp = oneSERule(janka.rm))
plot(janka.rmp)
text(janka.rmp)
plot(janka.rmp)
text(janka.rmp)
data(creditCards)
creditCards <- read.csv("creditCards.csv", header = TRUE, sep = ";")
str(creditCards)
Store(creditCards)
dim(creditCards)
set.seed(1234)
nCC <- nrow(creditCards)
train <- sample(nCC, 1000)
CCTrain <- creditCards[train, ]
CCTest <- creditCards[-train, ]
Store(CCTrain, CCTest) # for safe keeping
library(rpart)
CCTree <- rpart(credit.card.owner ~ ., CCTrain)
plot(CCTree)
text(CCTree)
Store(CCTree)
plotcp(CCTree)
CCPTree <- prune(CCTree, cp = oneSERule(CCTree))
plot(CCPTree)
text(CCPTree)
Store(CCPTree)
bagRpart <- local({
bsample <- function(dataFrame) # bootstrap sampling
dataFrame[sample(nrow(dataFrame), rep = TRUE), ]
function(object, data = eval.parent(object$call$data),
nBags=200, type = c("standard", "bayesian"), ...) {
type <- match.arg(type)
bagsFull <- vector("list", nBags)
if(type == "standard") {
for(j in 1:nBags)
bagsFull[[j]] <- update(object, data = bsample(data))
} else {
nCases <- nrow(data)
for(j in 1:nBags)
bagsFull[[j]] <- update(object, weights = rexp(nCases))
}
class(bagsFull) <- "bagRpart"
bagsFull
}
})
predict.bagRpart <- function(object, newdata, ...) {
X <- sapply(object, predict, newdata = newdata, type = "class")
candidates <- levels(predict(object[[1]], type = "class"))
X <- t(apply(X, 1, function(r) table(factor(r, levels = candidates))))
factor(candidates[max.col(X)], levels = candidates)
}
Store(bagRpart, predict.bagRpart)
if(!exists("CCSBag")) {
set.seed(4321)
Obj <- update(CCTree, cp = 0.005, minsplit = 9) # expand the tree
CCSBag <- bagRpart(Obj, nBags = 100)
CCBBag <- bagRpart(Obj, nBags = 100, type = "bayes")
rm(Obj)
Store(CCSBag, CCBBag)
}
n <- nrow(CCTest)
X <- replicate(100,
table(factor(sample(n, rep=TRUE), levels = 1:n)))
(lims <- range(rowSums(X > 0)))
rm(n, X)
suppressPackageStartupMessages(library(randomForest))
install.packages("randomForest")
suppressPackageStartupMessages(library(randomForest))
(CCRf <- randomForest(credit.card.owner ~ ., CCTrain, ntree = 100))
Store(CCRf)
v <- varImpPlot(CCRf) ## causes a plot
v <- sort(drop(v), decreasing = TRUE)
v[1:6]
bestFew <- setdiff(names(v)[1:20], "current.profession") # used later
form <- as.formula(paste("credit.card.owner ~", paste(bestFew, collapse = "+")))
Call <- substitute(glm(FORM, binomial, CCTrain), list(FORM = form))
CCGlmNaive <- eval(Call)
Store(CCGlmNaive)
if(!exists("CCGlmAIC")) {
upp <- paste("~", paste(setdiff(names(CCTrain), "credit.card.owner"),
collapse = "+"))
upp <- as.formula(upp)
start <- glm(credit.card.owner ~ mean.check.credits + gender,
binomial, CCTrain)
CCGlmAIC <- stepAIC(start, list(upper = upp, low = ~1), trace = FALSE)
CCGlmBIC <- stepAIC(CCGlmAIC, trace = FALSE, k = log(nrow(CCTrain)))
Store(CCGlmAIC, CCGlmBIC)
rm(start, upp)
}
install.packages("CCGlmAIC")
library(MASS)
if(!exists("CCGlmAIC")) {
upp <- paste("~", paste(setdiff(names(CCTrain), "credit.card.owner"),
collapse = "+"))
upp <- as.formula(upp)
start <- glm(credit.card.owner ~ mean.check.credits + gender,
binomial, CCTrain)
CCGlmAIC <- stepAIC(start, list(upper = upp, low = ~1), trace = FALSE)
CCGlmBIC <- stepAIC(CCGlmAIC, trace = FALSE, k = log(nrow(CCTrain)))
Store(CCGlmAIC, CCGlmBIC)
rm(start, upp)
}
Class <- function(object, newdata, ...)
UseMethod("Class")
Class.rpart <- function(object, newdata, ...)
predict(object, newdata, type = "class")
Class.bagRpart <- function(object, newdata, ...)
predict(object, newdata)
Class.randomForest <- predict
Class.glm <- function(object, newdata, ...) {
# only applies for binomial glms and symmetric link fns
predict(object,newdata) > 0
}
errorRate <- function(tab) 100*(1 - sum(diag(tab))/sum(tab))
true <- CCTest$credit.card.owner # $
sort(sapply(list(Tree = CCTree,
Pruned = CCPTree,
Bagging = CCSBag,
Bayes = CCBBag,
RandomF = CCRf,
NaiveGLM = CCGlmNaive,
Glm_AIC = CCGlmAIC,
Glm_BIC = CCGlmBIC),
function(x) errorRate(table(Class(x, CCTest), true))))
